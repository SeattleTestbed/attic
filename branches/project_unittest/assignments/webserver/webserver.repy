"""

<Program Name>
  server.repy


<Started>
  January 2009


<Author>
  Jenn Hanson


<Purpose>
  An implementation of the Seattle's webserver assignment.
  The server processes HTTP request concurently from multiple clients. 
  If a client does not send a request within 5 seconds of connecting, the server closes the connection to this client.

  It returns a valid HTTP response with one of the following:
  - listing of files in the current directory
  - the contents of a specific html or text file in the current directory
  - file not found error message if the request was valid but the file did not exist within the current directory
  - bad request message if the HTTP request was not properly formed 

  It has an optional command line arguement to specify the server port number 
  to which clients can connect.  If no port number is specified it will run on 
  port 12345.

"""

# constants
MAXIMUM_HTTP_REQUEST_SIZE = 3000 # maximum size of an acceptable http GET request since there is no specific protocol limit and it is implementation dependent I picked a conservatively high value
MAXIMUM_MSG_SIZE = 1024	    # maximum size of a message for the server to send
PORT = 12345	  # default server port number




def process_client(ip, port, client_conn, thiscommhandle, listencommhandle):

  """
  <Purpose>
     Processes a client connection by receiving an HTTP request, parsing it 
     to determine its validity, and send a response before closing the connection.
     If the client does not send a request within 5 seconds the connection will be closed. 
  <Arguments>
    ip: ip address
    port: port number
    client_conn: connection to client
    thiscommhandle:  a handler to the connection with the client
    listencommhandle:  a handler to the listener
  <Exceptions>
    None.
  <Side Effects>
    Closes thiscommhandle.
  <Returns>
    None.

  """

  # The lock is acquired so that no other client can reset the timer or concurrently open a file.
  mycontext['lock'].acquire()

  # Set a 5 second timeout for the connection to be closed if the client doesn't send a request.
  time_out = settimer(5.0, timed_out, [client_conn])

  try:
    data = get_data_from_client(client_conn)
    canceltimer(time_out)
    header = parse_msg(data)
    reply = make_reply(header)
    send_reply(reply, client_conn)
  except Exception, e:
    print 'Error while running the webserver:  '+str(e)
  finally:
    mycontext['lock'].release()
    stopcomm(thiscommhandle)





def get_data_from_client(client_conn):
  """
  <Purpose>
    Tries to get an entire HTTP GET request from a 'client'.
  <Arguments>
    client_conn: connection with client
  <Exceptions>
    None.
  <Side Effects>
    None.
  <Returns>
    Returns 414 if the you couldn't get the whole first line after 4000 bytes.
    Otherwise the first line of the GET request.
  """

  msg_recvd = ""
  num_bytes_recvd = 0

  while( num_bytes_recvd < MAXIMUM_HTTP_REQUEST_SIZE):
    #try to get more data from the client
    temp_recvd = client_conn.recv(1)
    #update the total number of bytes of data received from the connection
    num_bytes_recvd += len(temp_recvd)


    # Remove carriage returns, '\r' characters, from the new data received and then add it to the data you've already collected 
    # Some machines use '\r\n' as a newline character while others just use '\n'
    # So you can see 2 newline characters in a row on all machines as '\n\n'
    msg_recvd += temp_recvd
    msg_recvd = msg_recvd.replace("\r\n","\n")

    if ( msg_recvd.find("\n\n") != -1 ):
      return msg_recvd


  # the MAXIMUM_HTTP_REQUEST_SIZE number of bytes was read and the 2 newline characters couldn't be found
  # the GET request is too long so just quit now and return a 414 message
  return 414





def parse_msg(msg):
  """
  <Purpose>
    Parses the arguement msg to determine if it has a valid first line of an HTTP GET request. 
  <Arguments>
    msg: The string that represents an HTTP request.
  <Exceptions>
    None
  <Side Effects>
    None
  <Returns>
    Returns 400 if the message was ill formed.
    Returns the possible URL from the first line as a string.

  """
  #if the message received was too long and then you should get 414 as the msg parameter so just pass it along
  if (msg == 414):
    return msg


  header = 400

  if(msg.find('\n') > -1):

    # split the entire message by newlines to get the first line
    lines = msg.split('\n')

    #get rid of the 2 newline character sequence and any extra garbage after it
    parsedData = lines[0].split(' ')

    # Check that the first line contains only 3 "words": GET <url> HTTP<version>
    if(len(parsedData) == 3 and parsedData[0] == 'GET' and (parsedData[2] == 'HTTP/1.1' or parsedData[2] =='HTTP/1.0')):
      header = parsedData[1]

  return header





def make_reply(msg):
  """
  <Purpose>
    Forms a HTTP response to send to the client based on the msg arguements.  
    Forms either a 200 OK, 400 Bad Request, or 404 File Not Found response.
  <Arguments>
    msg: The string that either contains a potential url or 400 for bad request.
  <Exceptions>
    None
  <Side Effects>
    None
  <Returns>
    Returns a string that's a valid HTTP response for the client request.

  """

  if msg == 400:
    response = 'HTTP/1.1 400 Bad Request\n\n<h1>400 Bad Request</h1>'

  elif msg == 414:
    response = 'HTTP/1.1 414 URI Too Long\n\n<h1>414 URI Too Long</h1>'

  else:
    files = listdir()

    # Create a message with the list of the files in the current directory
    if(msg == '/'): 
      response = 'HTTP/1.1 200 Ok\n\n<h1>Files in Current Directory</h1>'
      for file in files:
        temp = '<p>' + file + '</p>'
        response += temp

    # Get the contents of a specific file
    else:  
      msg = msg.strip('/')
      found = 0
      for file in files:
        if(file == msg):
          found = 1
          response = 'HTTP/1.1 200 OK\n\n'
          try:
            fd = open(file, 'r')
            response += fd.read()
            fd.close()
          except:
            response = 'HTTP/1.1 404 File Not Found\n\n<h1> File could not be opened or read</h1>'
      if(found == 0):
        response = 'HTTP/1.1 404 File Not Found\n\n <h1>File Not Found</h1>'
  return response




# Sends response arguement to a client via the client connection and then closes it.
def send_reply(response, client_conn):
  count = 0
  length_of_msg = len(response)

  while(count < length_of_msg):
    string_to_send = ''
    max= count + MAXIMUM_MSG_SIZE

    if(max >= length_of_msg):
      string_to_send = response[count: ]
    else:
      string_to_send = response[count:max]

    num_sent = client_conn.send(string_to_send)
    count += num_sent

  client_conn.close()




# Closes client connection when called.
def timed_out(client_conn):
  client_conn.close()







if callfunc == 'initialize':
  mycontext['lock'] = getlock()
  ip = getmyip()
  print "listening for connection on: ", ip
  myport = PORT
  if len(callargs)>1:
    raise Exception("Too many call args")
  elif len(callargs) == 1:
    myport = int(callargs[0])
  listencommhandle = waitforconn(ip, myport, process_client)
