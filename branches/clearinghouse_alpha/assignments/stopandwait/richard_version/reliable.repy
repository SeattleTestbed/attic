"""
<Author>
  Richard Jordan

<Start Date>
  January 7th, 2009

<Description>
  An implementation of Seattle's Stop and Wait Assignment.  Uses
  an alternating bit to reliably send messages.
  See:
    https://seattle.cs.washington.edu/wiki/StopAndWaitAssignment.

<Usage>
  Public methods:
    reliable_config(maxdgramsize, retries, timeoutinms):
        Set up the protocol variables.

    reliable_sendmess(destip, destport, message, srcip=None, srcport=None):
        Let the reliable library split up messages into packets.  Then send them.
        Listen for ACKs to make sure the receiver gets them.

    reliable_recvmess(srcip, srcport, function):
        Set up a listener and handle messages.  Send back ACKs.

"""

# Constants
DEFAULT_MAXDGRAMSIZE = 5 # bytes of payload to send
DEFAULT_RETRIES = 4 # listen times for ack
DEFAULT_TIMEOUT = 1000 # miliseconds to wait
MILLISECONDS_TO_SECONDS = 1/1000.0 # conversion
DEFAULT_ALT_BIT = 0 # start alternating from 0
mycontext['DELIM'] = "~" # separates the packet into segments
########## Public Methods #############

# Set some context variables.
def reliable_config(maxdgramsize, retries, timeoutinms):
  """
    <Purpose>
      Sets up the passed state variables.

    <Arguments>
      maxdgramsize:
             The maximum number of bytes of payload in a message.
             The default is five bytes per payload.

      retries:
             Times to try sending a package before giving up.
             The default is four tries.

      timeoutinms:
             The time to wait for an ACK.  The default is 10 
             miliseconds.

    <Exceptions>
      Exception if the maxdgramsize is less than or equal to zero.
      Exception if the retries or timeout is less than zero.

    <Side Effects>
      Sets mycontext['_<argname>'].  Ex. mycontext['_maxdgramsize'].
      Allocates a lock as mycontext['_send_lock'].
      Sets mycontext['_configured'] to equal True.

    <Returns>
      Nothing.
  """
  if maxdgramsize <= 0:
    raise Exception("maximum datagram size cannot be <= zero")
  if retries < 0:
    raise Exception("retries cannot be < zero")
  if timeoutinms < 0:
    raise Exception("timeout cannot be < zero")

  mycontext['_maxdgramsize'] = maxdgramsize
  mycontext['_retries'] = retries
  mycontext['_timeoutinms'] = timeoutinms

  # Set up a lock for threads.
  mycontext['_send_lock'] = getlock()
  # Set up a lock for waiting for responses
  mycontext['_sleep_lock'] = getlock()

  # Has the protocol been configured?
  mycontext['_configured'] = True

# Handles splitting up packets
# Let's have the library handle splitting up packets.  Why
# would an application do that?
def reliable_sendmess(destip, destport, message, srcip=None, srcport=None):
  """
    <Purpose>
      Splits the given message into packets, wraps them in headers, and sends
      them using the Stop and Wait algorithm to the receiver.  Listens for
      ACK's to make sure the message is reliable.

    <Arguments>
      destip:
             The ip to communicate to

      destport:
             The port to communicate to.  The remote node's restrictions file 
             must allow this port as a messport.

      message:
             A string of data.  Ex. "hello world!"

      srcip:
             The ip to communicate from.  Probably is either '127.0.0.1' or
             the result from getmyip().  Defaults to getmyip().

      srcport:
             The port to communicate from.  The restrictions file must allow
             this port as a messport.

    <Exceptions>
      Exception if times out.

    <Side Effects>
      Sets up a UDP callback to listen for acks.
      Uses mycontext['_send_bit'].
      Calls reliable_config() with defaults.
      Locks mycontext['_send_lock'] when manipulating mycontext['_send_bit'].
 
    <Returns>
      The bytes sent.
  """

  # Make sure all the context variables are setup
  if not '_configured' in mycontext:
    reliable_config(DEFAULT_MAXDGRAMSIZE, DEFAULT_RETRIES, DEFAULT_TIMEOUT)

  # What should the optional arguments be then?
  # Let's pick this ip and the same port?
  # BUG: what about loopback? and if the port is taken?
  if(srcip == None or srcport == None):
    srcip = getmyip()
    srcport = destport

  # According to specs:
  # (snip)
  # A timeout of 0 ms disables retransmissions and 
  # causes reliable_sendmess to never report an unacknowledged datagram.
  # ...
  # A retries of 0 also disables retransmissions, but 
  # delays at least timeoutms before returning. 
  # Datagrams are never reported as lost. 
  # (snip)
  # So let's do it.
  if mycontext['_timeoutinms'] == 0:
    return sendmess(destip, destport, message, srcip, srcport)
  if mycontext['_retries'] == 0:
    # Ok, this is really stupid, buit it's what they want?
    sleep(mycontext['_timeoutinms'] * MILLISECONDS_TO_SECONDS)
    return sendmess(destip, destport, message, srcip, srcport)

  # Listen for the ack of the message
  ch = recvmess(srcip, srcport, process_ack)

  # Split up message by maxdgramsize?
  payloads = slices(message, mycontext['_maxdgramsize'])

  # Send it
  mycontext['_send_bit'] = DEFAULT_ALT_BIT
  alt_bit = mycontext['_send_bit']
  bytes = 0
  while payloads:
    payload = payloads.pop(0)
    datagram = pack_mess(alt_bit, payload)
    tries = 0

    # Stop and Wait Algorithm
    while True:        
      mycontext['_sleep_lock'].acquire()
      # Timeout error
      if tries > mycontext['_retries']:
        mycontext['_sleep_lock'].release()
        stopcomm(ch)
        raise Exception, "timeout, sent %d bytes" % bytes

      # Make sure our event handler isn't doing the same.
      mycontext['_send_lock'].acquire()      
      if alt_bit != mycontext['_send_bit']:
        alt_bit = mycontext['_send_bit']
        mycontext['_send_lock'].release()
        mycontext['_sleep_lock'].release()
        break  # message received!
      else:      # then try again
        mycontext['_send_lock'].release()
        bytes += sendmess(destip, destport, datagram, srcip, srcport)
        tries += 1
      
      mycontext['_sleep_timer'] = settimer(mycontext['_timeoutinms'] * MILLISECONDS_TO_SECONDS, release_sleep_lock, ())

  stopcomm(ch)

  return bytes

# Setup the callback for when we receive a payload.
# The callback will send an ack back.
# Save the application's function.
def reliable_recvmess(srcip, srcport, function):
  """
    <Purpose>
      Listens for data from a sender.  Sends ACK's back on receipt.

    <Arguments>
      srcip:
             The ip to communicate from.  Probably is either '127.0.0.1' or
             the result from getmyip().

      srcport:
             The port to communicate from.  The restrictions file must allow
             this port as a messport.
      
      function:
             A callback to receive the payloads.

    <Exceptions>
      None

    <Side Effects>
      Sets up UDP callback.  Sets mycontext['_function'].
      Sets mycontext['_recv_bit'].
      Sets up mycontext['_recv_lock'] for mycontext['_recv_bit'].

    <Returns>
      An event handler.
  """

  mycontext['_function'] = function
  mycontext['_recv_bit'] = DEFAULT_ALT_BIT
  # Set up a lock for threads.
  mycontext['_recv_lock'] = getlock()

  return recvmess(srcip, srcport, process_message)

###### Private functions ################

# Send back an "ack" and call the application's
# function.  Event setup by reliable_recvmess.
# Thread safe using mycontext['_recv_lock'].
def process_message(ip, port, mess, ch):
  # print "message: %s\n" % mess
  mycontext['_recv_lock'].acquire()
  alt_bit, payload = unpack_mess(mess)
  if alt_bit == mycontext['_recv_bit']:
    # print "sending ack...\n"
    mycontext['_recv_bit'] = toggle(mycontext['_recv_bit'])
    sendmess(ip, port, pack_mess(mycontext['_recv_bit'], "ack..."))
    mycontext['_function'](ip, port, payload, ch)
  else:
    # print "server says: duplicate\n"
    sendmess(ip, port, pack_mess(mycontext['_recv_bit'], "resending ack..."))
  mycontext['_recv_lock'].release()

# Set that we received an ack.  Event setup by reliable_sendmess.
# Thread safe using mycontext['_send_lock'].
def process_ack(ip, port, mess, ch):
  # print "ack: %s\n" % mess
  mycontext['_send_lock'].acquire()
  alt_bit, payload = unpack_mess(mess)
  if alt_bit != mycontext['_send_bit']:
    # print "receiving 'ack'\n"
    mycontext['_send_bit'] = toggle(mycontext['_send_bit'])
    if '_sleep_timer' in mycontext.keys():
      canceltimer(mycontext['_sleep_timer'])
    release_sleep_lock()
  else:
    # print "old ack\n"
    pass

  mycontext['_send_lock'].release()

# Flip the bit
def toggle(bit):
  if bit:
    return 0
  else:
    return 1

# Unpack a mess into parts
def unpack_mess(mess):
  res = mess.split(mycontext['DELIM'])
  bit = int(res[0])
  return (bit, ''.join(res[1:]))

# Pack up payload with header
def pack_mess(bit, payload):
  bit = str(bit)
  mess = bit + mycontext['DELIM'] + payload

  return mess

# Cuts a message into packets of slice_size bytes.
def slices(str, slice_size):
  start = 0 # index to slice from
  ans = [] # list of slices
  while start < len(str):
    ans += [str[start:start+slice_size]]
    start += slice_size

  return ans

# BUGFIX: 2/05/09
# Timeouts should end immediately
# when ACK comes. - RJ
def release_sleep_lock():
  mycontext['_sleep_lock'].release()
