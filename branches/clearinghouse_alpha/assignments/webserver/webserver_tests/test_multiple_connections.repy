ACCEPTABLE_MAX_TIME = 15  #maximum number of seconds acceptable for the server to process 100 requests


def grade(test_log_string):

  """
  <Purpose>
    Grades log output produced from running the test
  <Arguments>
    test_log_string:  string output from running the test
  <Exceptions>
     None.
  <Side Effects>
     None.
  <Returns>
     Returns a string stating that the test either passed or failed.
  """

  found = test_log_string.find('Test completed')
  if(found == -1):
    return 'FAILURE'
  else:
    return 'SUCCESS'
  



def recv_msg(conn, expected_msg):
  """
  <Purpose>
     Receives a message from the server and checks if it is the same as the expected message.
  <Arguments>
     conn:  connection to the server
     expected_msg:  first line of http response that was expected
  <Exceptions>
     None.
  <Side Effects>
     Closes the connection if a message is not received within the timeout range.
  <Returns>
    Returns a pair (passed, message).
    passed:  p if the first line of the server response was the same as expected
             f if there was an exception or the first line was different
    message:  returns the error message, the message from the server if it was different, or the first_line of the http response if it was correct


  """
  try:
    data = conn.recv(1024)
    lines = data.split('\n')
    first_line = lines[0].replace("\r","")
    if (first_line == expected_msg):
      return ('p', expected_msg)
    else:
      return ('f', "Server response was different than expected.\nExpected first line:  "+expected_msg+"\nReceived message:  "+ data)
  except Exception, e:
    return ('f', e)





def perform_test(msg, expected_response):
  """
  <Purpose>
    Perform a complete client transaction sending msg to the server and testing if the  expected_response was obtained.
  <Arguments>
    msg:  http request to send to the server
    expected_response:  expected first line of http response from the server
  <Exceptions>
    None.
  <Side Effects>
    None.
  <Returns>
    Returns a message indicating the test passed or an error.

  """
  try:
    conn = openconn(mycontext['host'], mycontext['port'])
    conn.send(msg)
  except Exception, e:
    return "test failed:    " + str(e)

  (passed, response) = recv_msg(conn, expected_response)
  if(passed == 'f'):
      return "test failed:   " + str(response)

  try:
    conn.close()
  except Exception, e:
    return "test failed:    " + str(e)

  return 'test completed'





def test_multiple_connections():
  """
  <Purpose>
    Tests the run time for 100 get requests to the server.
  <Arguments>
    None.
  <Exceptions>
    None.
  <Side Effects>
    None.
  <Returns>
    Returns the time that the method took to make 100 'transactions' or an 
    error message with the stats collected on the number of connections that actually passed.

  """
  count = 0
  start_time = getruntime()
  while(count < 100):
    test = perform_test('GET / HTTP/1.1\n','HTTP/1.1 200 Ok')
    if (test != 'test completed'):
      # the transaction didn't work
      end_time = getruntime()
      return "Error.  A client transaction failed with the following error:  "+ test + "\n" + str(count) + " connections passed with a total time of " + str(end_time - start_time) + " seconds."
    count = count + 1
  end_time = getruntime()
  total_time = end_time - start_time
  test_results = ''
  if (total_time > ACCEPTABLE_MAX_TIME):
    test_results = 'Test failed; The server took too long to process the requests.\n'
  else:
    test_results = 'Test completed.\n'
  test_results = test_results + "Total time for 100 client connections :  " + str(total_time) + " seconds \nAverage time per connection: " + str(total_time/100) + " seconds"
  return test_results





if callfunc == 'initialize':
  if len(callargs) != 2:
    raise Exception("Wrong number of  call args.  This program takes two arguements <server_ip> <port_number>")
  else:
    mycontext['host'] = callargs[0]
    mycontext['port'] = int(callargs[1])
    client_ip = getmyip()

    print 'Testing 100 client transactions . . .'
    print test_multiple_connections()