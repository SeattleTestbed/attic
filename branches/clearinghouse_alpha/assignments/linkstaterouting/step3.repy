# This data structure contains connection information.   It is a dictionary
# that maps destip to the corresponding socket
routerconnections = {}


# This contains the srcip destip values that this router knows.
knownrouterstate = []


# allow routing and data packets...
# packets of type 'R' are routing, 'D' are data.
ALLOWEDMESSAGETYPES = ['R', 'D']


# When I get a connection, add it to the routerconnections data structure
def gotconnection(srcip, srcport, socketobj, mainch, ch):
  # someone is connected to me...

  if srcip in routerconnections:
    raise Exception("Internal Error: someone I was already connected to connected to me ("+str(srcip)+")")

  routerconnections[srcip] = socketobj



# I don't want there to be a race condition when sending messages
messagesendlock = getlock()
 


# This sends a packet
def sendpacketoverlink(socketobj, messagetype, messagestring):
  if messagetype not in ALLOWEDMESSAGETYPES:
    print "unknown message type: '"+messagetype+"'"
    return

  messagebody = messagetype+messagestring
  message = str(len(messagebody))+":"+messagebody

  messagesendlock.acquire()
  socketobj.send(message)
  messagesendlock.release()
 

# Gather some useful statistics...
stats = {}
stats['fwdcount'] = 0
stats['rcvcount'] = 0

# send a message over all links.   It is assumed to be 'R' type (routing)
def floodroutingmessage(messagestring):

  for connection in routerconnections:
    stats['fwdcount'] = stats['fwdcount'] + 1
    sendpacketoverlink(routerconnections[connection], 'R', messagestring) 

  

# this holds routing messages to prevent messages from being forwarded multiple
# times.  If you wanted to implement a TTL scheme, you should remove the lines
# that refer to this list from the code.
previouslyreceivedmessages = []


# Manage an incoming message
def handlemessage(messagetype, messagebody):
  if messagetype not in ALLOWEDMESSAGETYPES:
    print "unknown message type: '"+messagetype+"'"
    return

  # a routing message
  if messagetype == 'R':


    if messagebody in previouslyreceivedmessages:
      # it is a duplicate so don't forward to avoid packets circling forever
      return
    
    previouslyreceivedmessages.append(messagebody)

    # add this to the table
    srcip, destip = messagebody.split()
    knownrouterstate.append([srcip, destip])

    # and flood it so others can see this state.
    floodroutingmessage(messagebody)
    return

  if messagetype == 'D':
    print 'Not implemented yet'

  


# this receives messages on a connection.   There is one of these per link
def receivemessages(socketobj,remoteip):
  try: 
    while True:
      lengthstring = ''

      readbyte = ''
      while readbyte != ':':
        lengthstring = lengthstring + readbyte
        readbyte = socketobj.recv(1)

      length = int(lengthstring)
  
      message = socketobj.recv(length)
        
      messagetype = message[0]
      messagebody = message[1:]

      stats['rcvcount'] = stats['rcvcount'] + 1
      handlemessage(messagetype, messagebody)

  except Exception, e:
    print 'Failure ',e,' when talking with ',remoteip
    # let's continue



# Start the thread up that are needed to route traffic
def startrouting():
  for connection in routerconnections:
    settimer(0, receivemessages, (routerconnections[connection],connection))


    


if callfunc == 'initialize':
  if len(callargs) != 2:
    raise Exception("Must be called with file to read map data from and the port")

  # listen for connections...
  myip = getmyip()
  myport = int(callargs[1])
  waitforconn(myip, myport, gotconnection)

  sleep(60-getruntime())

  # this is what I will send to my peers
  statetoflood = []

  inputfn = callargs[0]
  # Walk through the file and look for things I'm supposed to do...
  for line in file(inputfn):
    srcip, destip = line.split()
    # If this is me, then open a connection and put it in the routerconnections
    # table...
    if srcip == myip:
      routerconnections[destip] = openconn(destip,myport)
      # I need to flood this...
      statetoflood.append(srcip+" "+destip)



  sleep(120-getruntime())
  # ready to forward packets
  startrouting()

  
  print 'connected to:', routerconnections
  sleep(180-getruntime())

  # let's send out our state...
  for messagestring in statetoflood:
    print 'starting:',messagestring
    floodroutingmessage(messagestring)

  print 'done flooding'
  sleep(240-getruntime())
 
  # This is where I would build the actual routing tables, but I'll print
  # stats and exit now...
  
  print stats
  knownrouterstate.sort()
  print knownrouterstate
  print "unique message count:",len(previouslyreceivedmessages)
  print getruntime()
  exitall()

  
