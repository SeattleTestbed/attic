# This data structure contains connection information.   It is a dictionary
# that maps destip to the corresponding socket
routerconnections = {}


# This contains the srcip destip values that this router knows.
knownrouterstate = []


# allow routing and data packets...
# packets of type 'R' are routing, 'D' are data.
ALLOWEDMESSAGETYPES = ['R', 'D']


# When I get a connection, add it to the routerconnections data structure
def gotconnection(srcip, srcport, socketobj, mainch, ch):
  # someone is connected to me...

  if srcip in routerconnections:
    raise Exception("Internal Error: someone I was already connected to connected to me ("+str(srcip)+")")

  routerconnections[srcip] = socketobj



# I don't want there to be a race condition when sending messages
messagesendlock = getlock()
 


# This sends a packet
def sendpacketoverlink(socketobj, messagetype, messagestring):
  if messagetype not in ALLOWEDMESSAGETYPES:
    print "unknown message type: '"+messagetype+"'"
    return

  messagebody = messagetype+messagestring
  message = str(len(messagebody))+":"+messagebody

  messagesendlock.acquire()
  socketobj.send(message)
  messagesendlock.release()
 

# Gather some useful statistics...
stats = {}
stats['fwdcount'] = 0
stats['rcvcount'] = 0

# send a message over all links.   It is assumed to be 'R' type (routing)
def floodroutingmessage(messagestring):

  for connection in routerconnections:
    stats['fwdcount'] = stats['fwdcount'] + 1
    sendpacketoverlink(routerconnections[connection], 'R', messagestring) 

  

# this holds routing messages to prevent messages from being forwarded multiple
# times.  If you wanted to implement a TTL scheme, you should remove the lines
# that refer to this list from the code.
previouslyreceivedmessages = []


# Manage an incoming message
def handlemessage(messagetype, messagebody):
  if messagetype not in ALLOWEDMESSAGETYPES:
    print "unknown message type: '"+messagetype+"'"
    return

  # a routing message
  if messagetype == 'R':


    if messagebody in previouslyreceivedmessages:
      # it is a duplicate so don't forward to avoid packets circling forever
      return
    
    previouslyreceivedmessages.append(messagebody)

    # add this to the table
    srcip, destip = messagebody.split()
    knownrouterstate.append([srcip,destip])

    # and flood it so others can see this state.
    floodroutingmessage(messagebody)
    return

  if messagetype == 'D':
    src, dest = messagebody.split()

    # if it's for me, deliver it...
    if dest == myip:
      print getruntime(),'deliver:',messagebody

    else:
      # send it to the next hop
      routenexthop = routingtable[dest][0]
      sendpacketoverlink(routerconnections[routenexthop], messagetype, messagebody)
#      print 'forward:',messagebody,'headed to ',dest,"via",routenexthop

    return

  


# this receives messages on a connection.   There is one of these per link
def receivemessages(socketobj,remoteip):
  try: 
    while True:
      lengthstring = ''

      readbyte = ''
      while readbyte != ':':
        lengthstring = lengthstring + readbyte
        readbyte = socketobj.recv(1)

      length = int(lengthstring)
  
      message = socketobj.recv(length)
        
      messagetype = message[0]
      messagebody = message[1:]

      stats['rcvcount'] = stats['rcvcount'] + 1
      handlemessage(messagetype, messagebody)

  except Exception, e:
    print 'Failure ',e,' when talking with ',remoteip
    # let's continue



# Start the thread up that are needed to route traffic
def startrouting():
  for connection in routerconnections:
    settimer(0, receivemessages, (routerconnections[connection],connection))



# takes a list of [srcip, destip, weight] and returns a dictionary that
# has a key for each destination with the hop list as the values.
def dijkstrasalgorithm(routeinfo):

  nodelist = []
  for srcip, destip, weight in routeinfo:
    if srcip not in nodelist:
      nodelist.append(srcip)


  # build a dict with connection data
  nodeconnectiondata = {}
  for node in nodelist:
    nodeconnectiondata[node] = []

  for srcip, destip, weight in routeinfo:
    nodeconnectiondata[srcip].append([destip, weight])


  # this is the set of node distances
  nodedistance = {}
  nodepath = {}
  visited = {}

  for node in nodelist:
    # 10**10 is essentially infinite
    nodedistance[node] = 10**10
    nodepath[node] = []
    visited[node] = False

  nodedistance[myip] = 0

  currentnode = myip

  # we will break out when we've been through all of the nodes
  while currentnode:

    currentdistance = nodedistance[currentnode]
    print 'nodedistance:',currentnode, currentdistance

    for neighbor, neighborweight in nodeconnectiondata[currentnode]:
      if visited[neighbor]:
        continue


      if nodedistance[neighbor] > currentdistance + neighborweight:
        nodedistance[neighbor] = currentdistance + neighborweight
        nodepath[neighbor] = nodepath[currentnode] + [neighbor]

    # finished with this node, let's mark it visited and find the next one
    visited[currentnode] = True

    currentnode = None
    smallestdistance = 10**10
    for node in nodelist:
      if not visited[node] and nodedistance[node] < smallestdistance:
        smallestdistance = nodedistance[node]
        currentnode = node


  # until we add weights, the cost should be equal to the hop count...
#  for node in nodelist:
#    assert(len(nodepath[node]) == nodedistance[node])

  return nodepath

    

def calculate_link_weights(linkfile, routerstate):

  # compute a dict mapping (srcip, destip) to weight so I can easily add them
  weightmapping = {}
  for line in file(linkfile):
    srcip, destip, weight = line.split()
    weight = int(weight)
    weightmapping[(srcip,destip)] = weight
    weightmapping[(destip,srcip)] = weight

  weightedstate = []

  # let's add weights.   For right now, they all will be 1  
  for [srcip,destip] in routerstate:    
    weightedstate.append([srcip,destip,weightmapping[(srcip, destip)]])  

  return weightedstate
  



if callfunc == 'initialize':
  if len(callargs) != 2:
    raise Exception("Must be called with file to read map data from and the port")

  # listen for connections...
  myip = getmyip()
  myport = int(callargs[1])
  waitforconn(myip, myport, gotconnection)

  sleep(60-getruntime())

  # this is what I will send to my peers
  statetoflood = []

  inputfn = callargs[0]
  # Walk through the file and look for things I'm supposed to do...
  for line in file(inputfn):
    srcip, destip = line.split()
    # If this is me, then open a connection and put it in the routerconnections
    # table...
    if srcip == myip:
      routerconnections[destip] = openconn(destip,myport)
      # I need to flood this...
      statetoflood.append(srcip+" "+destip)



  sleep(120-getruntime())
  # ready to forward packets
  startrouting()

  
  sleep(180-getruntime())

  # let's send out our state...
  for messagestring in statetoflood:
    floodroutingmessage(messagestring)

  print 'done flooding'
  sleep(240-getruntime())
 
  # This is where I build the actual routing tables
  # first, make the links symmetric
  for [srcip,destip] in knownrouterstate[:]:
    knownrouterstate.append([destip,srcip])  

  weightedknownrouterstate = calculate_link_weights('linkcost.txt', knownrouterstate)


  # time to create the routing table...
  routingtable = dijkstrasalgorithm(weightedknownrouterstate) 
  print "constructed routing table"
    
  print routingtable
  sleep(270-getruntime())

  # let's send some test messages...
  
  for node in routingtable:
    if node == myip:
      continue
    nexthop = routingtable[node][0]
    sendpacketoverlink(routerconnections[nexthop], 'D', myip+" "+node)
    print getruntime(),'sending', myip, node,'to',nexthop
  

  sleep(330-getruntime())
  print "unique message count:",len(previouslyreceivedmessages)
  print getruntime()
  exitall()

  
